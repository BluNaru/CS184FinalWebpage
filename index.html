<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Final Projectr</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184 Final Project</h1>
<h2 align="middle">Team 52: James Fang, Lea Nakatsukasa, Nicholas Pels</h2>

<br><br>
  
  <p> <strong>Final Video:</strong></p>
  
  <p> <strong>Abstract:</strong> </p>
    <p>Our project was to build a procedurally generated solar system to explore other computer graphic techniques that were not discussed in class. We got our idea from a series of YouTube videos made by Sebastian Lague, where he goes through step-by-step how to create a rocky planet in Unity3D with continents, biomes, and oceans. We wanted to take this a step further by creating an entire solar system with rocky planets and gaseous planets orbiting around a star. The planet’s would be randomly generated and could later be edited by the user. When our demonstration is run, the user can see the orbits of the planets around the star and can zoom in on a specific planet to view and edit it.  </p>

  <p> <strong>Technical Approach:</strong> </p>
    <p>The main process for creating rocky planets was outlined in Lague’s planet generation series. First, we needed a spherical mesh to represent the base of the planet. We started by taking a cubical mesh and making all the vertices equidistant from the center to get the sphere. The radius and base color of the planet were made to be edited so that the planet could be set up to have a random radius and color assigned to it. </p>
  
    <p>For the physical simulation of the solar system, we used Newton’s equation for gravity: F=<box>GM<sub>1</sub>M<sub>2</sub>/r<sup>2</sup></box>. Each frame, we use this equation to calculate the acceleration each planet experiences from the star in the middle. We then use Huen’s method to integrate the velocity and position. The updates are as follows: </p>
        <div align="center">
        <table style="width=100%">
            <tr>
                <td align="middle">
                    <img src="images/equation1.png" width="240px" />
                </td>
            </tr>
          <tr>
                <td align="middle">
                    <img src="images/equation2.png" width="240px" />
                </td>
            </tr>
        </table>
    </div>
    <p>where p and v are position and velocity respectively. This is a simplified version of the famous Runge-Kutta method for integration. We found that this was slightly more accurate than Verlet integration, which we learned in class. </p>
    <p>It is also important that the planets have an initial velocity that is tangential to the gravity vector. This allows the orbiting behavior. Otherwise, the planets would simply crash into the burning star, and we would be terrible gods. The higher this initial velocity is, the more elliptical the orbits become. </p>
  <p> <strong>Results:</strong> </p>
  
  <p> <strong>References:</strong> </p>
    <p>Board to Bits Games. Making a Custom Planet Ring in Unity. https://www.youtube.com/watch?v=Rze4GEFrYYs </p>
    <p>Lague, Sebastian. Unity Procedural Planet Generation. https://www.youtube.com/watch?v=QN39W020LqU&list=PLFt_AvWsXl0cONs3T0By4puYy6GM22ko8 </p>
    
  <p> <strong>Contributions from each team member:</strong> </p>
    <p>James Fang: </p>
    <p>Lea Nakatsukasa: </p>
    <p>Nicholas Pels: </p>
  
  
</body>
</html>
